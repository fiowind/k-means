#! /usr/bin/env python
#
# Copyright 2013 fio.wind <fiowind.zfx@gmail.com>

'''
K-MEANS:
	1.INPUT THE DATA AND THE K
	2.CREATE THE FIRST CLUSTERS
	3.SECOND DO THE ITERATIONS
		A.ASSIGNMENT STEP: ASSIGN EACH OBSERVATION TO THE CLUSTER WHOSE MEAN IS CLOSEST TO IT 
		(I.E. PARTITION THE OBSERVATIONS ACCORDING TO THE VORONOI DIAGRAM GENERATED BY THE MEANS).
		B.UPDATE STEP: CALCULATE THE NEW MEANS TO BE THE CENTROIDS OF THE OBSERVATIONS IN THE NEW CLUSTERS.
    4.UNTIL THE ALGORITHM HAS CONVERGED WHEN THE ASSIGNMENTS NO LONGER CHANGE.
'''

import random
import sys
import math

fin = open("./input1.txt", mode='r')
fout = open("./output.txt", mode='w')

# Read data and split it into substrings
data = fin.read()
data = data.split()

# input the number of k
k = input('Please input the number of clusters:')
# k=4

def init_cc(point,centroid):
	#this loop creates a parallel list of xpos and ypos
	#also it converts every ypos and xpos to an int
	for index,value in enumerate(data):
		if index % 2==0:
			point.append([int(data[index]),int(data[index+1])])

	# keep repeating this loop until k uniqe and random points have been chosen
	for i in range(k):
		item = random.randint(0,len(point))
		insert = point[item]
		# print insert
		if centroid.count(insert)==0:
			centroid.append(insert)

# distance point1, point2 takes two lists of ordered pairs and calculates
# the distance between them
def distance(point1,point2):
	d = math.sqrt( (point1[0] - point2[0])**2 + (point1[1] - point2[1])**2)
	return d

# This function takes the point and centroid lists and partitions
# the data into clusters based on distance from each centroid
def clustering(point,centroid):
	clusters = []
	for i in range(k):
		clusters.append([])
	#Find points that are closest to each centroid
	for p in point:
		temp_distance = 0 
		temp_index = 0
		for i,j in enumerate(centroid):
			# print i
			if i==0:
				temp_distance=distance(p,j)
				temp_index = i
			elif distance(p,j)<temp_distance:
				temp_distance = distance(p,j)
				temp_index = i
		clusters[temp_index].append(p)
	return clusters

#This function takes the list of points and centroids
# and recalculates the centroids to match the center points of the clusters	
def refresh_centroid(clusters):
	centroid = []
	for cluster in clusters:
		sumx = 0
		sumy = 0
		for point in cluster:
			sumx = sumx + point[0]
			sumy = sumy + point[1]
		averx = sumx / len(cluster)
		avery = sumy / len(cluster)
		centroid.append([averx,avery])
	return centroid

#This function verdict if the clusters is stable
def is_stable(centroid1,centroid2):
	for i in range(k):
		if centroid1[i]!=centroid2[i]:
			return False
	return True
	

if __name__ == '__main__':
	point = []
	centroid1 = []
	centroid2 = []
	init_cc(point,centroid1)   #choose k random points
	# print "point%s"%point
	# print 'centroid1%s'%centroid1
	clusters = clustering(point,centroid1)
	centroid2 = refresh_centroid(clusters)

	# keep repeating this loop until k uniqe points have been chosen
	while centroid1!=centroid2 :
		centroid1 = centroid2
		clusters = clustering(point,centroid1)    #a)clustering 
		centroid2 = refresh_centroid(clusters)    #b)refresh centroid of every cluster
		print clusters
		print centroid2
	#write final data to out.txt
	for i,j in enumerate(clusters):
		line = 'cluster '+str(i)+'\n'+str(j)+'\n'
		print line
		fout.write(line)

fin.close()
fout.close()
